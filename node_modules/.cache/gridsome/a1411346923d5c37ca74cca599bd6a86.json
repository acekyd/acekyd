{"remainingRequest":"/Users/adewaleabati/Documents/code/acekyd/node_modules/babel-loader/lib/index.js??ref--1-1!/Users/adewaleabati/Documents/code/acekyd/node_modules/gridsome/app/fetch.js","dependencies":[{"path":"/Users/adewaleabati/Documents/code/acekyd/node_modules/gridsome/app/fetch.js","mtime":499162500000},{"path":"/Users/adewaleabati/Documents/code/acekyd/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/adewaleabati/Documents/code/acekyd/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es.array.concat\";\nimport \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.to-string\";\nimport prefetch from './utils/prefetch';\nimport { unslashEnd } from './utils/helpers';\nimport { NOT_FOUND_PATH } from '~/.temp/constants';\nvar dataUrl = process.env.DATA_URL;\nvar isPrefetched = {};\nvar isLoaded = {};\nexport default (function (route) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$shouldPrefet = options.shouldPrefetch,\n      shouldPrefetch = _options$shouldPrefet === void 0 ? false : _options$shouldPrefet,\n      _options$force = options.force,\n      force = _options$force === void 0 ? false : _options$force;\n\n  if (!process.isStatic) {\n    var _route$meta$dynamic = route.meta.dynamic,\n        dynamic = _route$meta$dynamic === void 0 ? false : _route$meta$dynamic;\n    var path = dynamic ? route.matched[0].path : route.path;\n\n    if (route.name === '*') {\n      path = NOT_FOUND_PATH;\n    }\n\n    return new Promise(function (resolve, reject) {\n      if (force || !isLoaded[route.path]) {\n        isLoaded[route.path] = fetch(process.env.GRAPHQL_ENDPOINT, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            path: path,\n            dynamic: dynamic\n          })\n        }).then(function (res) {\n          return res.json();\n        })[\"catch\"](reject);\n      }\n\n      isLoaded[route.path].then(function (res) {\n        if (res.errors) reject(res.errors[0]);else if (res.code) resolve({\n          code: res.code\n        });else resolve({\n          data: res.data,\n          context: res.extensions ? res.extensions.context : {}\n        });\n        isLoaded[route.path] = null;\n      });\n    });\n  }\n\n  var hashMeta = document.querySelector('meta[name=\"gridsome:hash\"]').getAttribute('content');\n  return new Promise(function (resolve, reject) {\n    var usePath = route.name === '*' ? NOT_FOUND_PATH : route.path;\n    var jsonPath = route.meta.dataPath || unslashEnd(usePath) + '/index.json';\n    var absPath = unslashEnd(dataUrl) + jsonPath;\n\n    if (shouldPrefetch && !isLoaded[jsonPath]) {\n      if (!isPrefetched[jsonPath]) {\n        isPrefetched[jsonPath] = prefetch(absPath);\n      }\n\n      return isPrefetched[jsonPath].then(function () {\n        return resolve();\n      })[\"catch\"](function () {\n        return resolve();\n      });\n    }\n\n    if (!isLoaded[jsonPath]) {\n      isLoaded[jsonPath] = fetchJSON(absPath);\n    }\n\n    return isLoaded[jsonPath].then(function (res) {\n      if (res.hash !== hashMeta) reject(createError('Hash did not match.', 'INVALID_HASH'));else resolve(res);\n    })[\"catch\"](reject);\n  });\n});\n\nfunction createError(message, code) {\n  var error = new Error(message);\n  error.code = code;\n  return error;\n}\n\nfunction fetchJSON(jsonPath) {\n  return new Promise(function (resolve, reject) {\n    var req = new XMLHttpRequest();\n    req.open('GET', jsonPath, true);\n    req.withCredentials = true;\n\n    req.onload = function () {\n      switch (req.status) {\n        case 200:\n          {\n            var results;\n\n            try {\n              results = JSON.parse(req.responseText);\n            } catch (err) {\n              return reject(new Error(\"Failed to parse JSON from \".concat(jsonPath, \". \").concat(err.message, \".\")));\n            }\n\n            if (!results.hash) {\n              return reject(new Error(\"JSON data in \".concat(jsonPath, \" is missing a hash.\")));\n            }\n\n            return resolve(results);\n          }\n\n        case 404:\n          {\n            return reject(createError(req.statusText, req.status));\n          }\n      }\n\n      reject(new Error(\"Failed to fetch \".concat(jsonPath, \".\")));\n    };\n\n    req.send(null);\n  });\n}",{"version":3,"sources":["/Users/adewaleabati/Documents/code/acekyd/node_modules/gridsome/app/fetch.js"],"names":["prefetch","unslashEnd","NOT_FOUND_PATH","dataUrl","process","env","DATA_URL","isPrefetched","isLoaded","route","options","shouldPrefetch","force","isStatic","meta","dynamic","path","matched","name","Promise","resolve","reject","fetch","GRAPHQL_ENDPOINT","method","headers","body","JSON","stringify","then","res","json","errors","code","data","context","extensions","hashMeta","document","querySelector","getAttribute","usePath","jsonPath","dataPath","absPath","fetchJSON","hash","createError","message","error","Error","req","XMLHttpRequest","open","withCredentials","onload","status","results","parse","responseText","err","statusText","send"],"mappings":";;;AAAA,OAAOA,QAAP,MAAqB,kBAArB;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SAASC,cAAT,QAA+B,mBAA/B;AAEA,IAAMC,OAAO,GAAGC,OAAO,CAACC,GAAR,CAAYC,QAA5B;AACA,IAAMC,YAAY,GAAG,EAArB;AACA,IAAMC,QAAQ,GAAG,EAAjB;AAEA,gBAAe,UAACC,KAAD,EAAyB;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;AAAA,8BACYA,OADZ,CAC9BC,cAD8B;AAAA,MAC9BA,cAD8B,sCACb,KADa;AAAA,uBACYD,OADZ,CACNE,KADM;AAAA,MACNA,KADM,+BACE,KADF;;AAGtC,MAAI,CAACR,OAAO,CAACS,QAAb,EAAuB;AAAA,8BACOJ,KAAK,CAACK,IADb,CACbC,OADa;AAAA,QACbA,OADa,oCACH,KADG;AAErB,QAAIC,IAAI,GAAGD,OAAO,GAAGN,KAAK,CAACQ,OAAN,CAAc,CAAd,EAAiBD,IAApB,GAA2BP,KAAK,CAACO,IAAnD;;AAEA,QAAIP,KAAK,CAACS,IAAN,KAAe,GAAnB,EAAwB;AACtBF,MAAAA,IAAI,GAAGd,cAAP;AACD;;AAED,WAAO,IAAIiB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,UAAIT,KAAK,IAAI,CAACJ,QAAQ,CAACC,KAAK,CAACO,IAAP,CAAtB,EAAoC;AAClCR,QAAAA,QAAQ,CAACC,KAAK,CAACO,IAAP,CAAR,GAAuBM,KAAK,CAAClB,OAAO,CAACC,GAAR,CAAYkB,gBAAb,EAA+B;AACzDC,UAAAA,MAAM,EAAE,MADiD;AAEzDC,UAAAA,OAAO,EAAE;AAAE,4BAAgB;AAAlB,WAFgD;AAGzDC,UAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AAAEZ,YAAAA,IAAI,EAAJA,IAAF;AAAQD,YAAAA,OAAO,EAAPA;AAAR,WAAf;AAHmD,SAA/B,CAAL,CAKpBc,IALoB,CAKf,UAAAC,GAAG;AAAA,iBAAIA,GAAG,CAACC,IAAJ,EAAJ;AAAA,SALY,WAMdV,MANc,CAAvB;AAOD;;AAEDb,MAAAA,QAAQ,CAACC,KAAK,CAACO,IAAP,CAAR,CACGa,IADH,CACQ,UAAAC,GAAG,EAAI;AACX,YAAIA,GAAG,CAACE,MAAR,EAAgBX,MAAM,CAACS,GAAG,CAACE,MAAJ,CAAW,CAAX,CAAD,CAAN,CAAhB,KACK,IAAIF,GAAG,CAACG,IAAR,EAAcb,OAAO,CAAC;AAAEa,UAAAA,IAAI,EAAEH,GAAG,CAACG;AAAZ,SAAD,CAAP,CAAd,KACAb,OAAO,CAAC;AACXc,UAAAA,IAAI,EAAEJ,GAAG,CAACI,IADC;AAEXC,UAAAA,OAAO,EAAEL,GAAG,CAACM,UAAJ,GACLN,GAAG,CAACM,UAAJ,CAAeD,OADV,GAEL;AAJO,SAAD,CAAP;AAOL3B,QAAAA,QAAQ,CAACC,KAAK,CAACO,IAAP,CAAR,GAAuB,IAAvB;AACD,OAZH;AAaD,KAxBM,CAAP;AAyBD;;AAED,MAAMqB,QAAQ,GAAGC,QAAQ,CACtBC,aADc,CACA,4BADA,EAEdC,YAFc,CAED,SAFC,CAAjB;AAIA,SAAO,IAAIrB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAMoB,OAAO,GAAGhC,KAAK,CAACS,IAAN,KAAe,GAAf,GAAqBhB,cAArB,GAAsCO,KAAK,CAACO,IAA5D;AACA,QAAM0B,QAAQ,GAAGjC,KAAK,CAACK,IAAN,CAAW6B,QAAX,IAAuB1C,UAAU,CAACwC,OAAD,CAAV,GAAsB,aAA9D;AACA,QAAMG,OAAO,GAAG3C,UAAU,CAACE,OAAD,CAAV,GAAsBuC,QAAtC;;AAEA,QAAI/B,cAAc,IAAI,CAACH,QAAQ,CAACkC,QAAD,CAA/B,EAA2C;AACzC,UAAI,CAACnC,YAAY,CAACmC,QAAD,CAAjB,EAA6B;AAC3BnC,QAAAA,YAAY,CAACmC,QAAD,CAAZ,GAAyB1C,QAAQ,CAAC4C,OAAD,CAAjC;AACD;;AAED,aAAOrC,YAAY,CAACmC,QAAD,CAAZ,CACJb,IADI,CACC;AAAA,eAAMT,OAAO,EAAb;AAAA,OADD,WAEE;AAAA,eAAMA,OAAO,EAAb;AAAA,OAFF,CAAP;AAGD;;AAED,QAAI,CAACZ,QAAQ,CAACkC,QAAD,CAAb,EAAyB;AACvBlC,MAAAA,QAAQ,CAACkC,QAAD,CAAR,GAAqBG,SAAS,CAACD,OAAD,CAA9B;AACD;;AAED,WAAOpC,QAAQ,CAACkC,QAAD,CAAR,CACJb,IADI,CACC,UAAAC,GAAG,EAAI;AACX,UAAIA,GAAG,CAACgB,IAAJ,KAAaT,QAAjB,EAA2BhB,MAAM,CAAC0B,WAAW,CAAC,qBAAD,EAAwB,cAAxB,CAAZ,CAAN,CAA3B,KACK3B,OAAO,CAACU,GAAD,CAAP;AACN,KAJI,WAKET,MALF,CAAP;AAMD,GAzBM,CAAP;AA0BD,CApED;;AAsEA,SAAS0B,WAAT,CAAsBC,OAAtB,EAA+Bf,IAA/B,EAAqC;AACnC,MAAMgB,KAAK,GAAG,IAAIC,KAAJ,CAAUF,OAAV,CAAd;AACAC,EAAAA,KAAK,CAAChB,IAAN,GAAaA,IAAb;AACA,SAAOgB,KAAP;AACD;;AAED,SAASJ,SAAT,CAAoBH,QAApB,EAA8B;AAC5B,SAAO,IAAIvB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAM8B,GAAG,GAAG,IAAIC,cAAJ,EAAZ;AAEAD,IAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgBX,QAAhB,EAA0B,IAA1B;AACAS,IAAAA,GAAG,CAACG,eAAJ,GAAsB,IAAtB;;AAEAH,IAAAA,GAAG,CAACI,MAAJ,GAAa,YAAM;AACjB,cAAQJ,GAAG,CAACK,MAAZ;AACE,aAAK,GAAL;AAAU;AACR,gBAAIC,OAAJ;;AAEA,gBAAI;AACFA,cAAAA,OAAO,GAAG9B,IAAI,CAAC+B,KAAL,CAAWP,GAAG,CAACQ,YAAf,CAAV;AACD,aAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,qBAAOvC,MAAM,CACX,IAAI6B,KAAJ,qCAAuCR,QAAvC,eAAoDkB,GAAG,CAACZ,OAAxD,OADW,CAAb;AAGD;;AAED,gBAAI,CAACS,OAAO,CAACX,IAAb,EAAmB;AACjB,qBAAOzB,MAAM,CACX,IAAI6B,KAAJ,wBAA0BR,QAA1B,yBADW,CAAb;AAGD;;AAED,mBAAOtB,OAAO,CAACqC,OAAD,CAAd;AACD;;AACD,aAAK,GAAL;AAAU;AACR,mBAAOpC,MAAM,CAAC0B,WAAW,CAACI,GAAG,CAACU,UAAL,EAAiBV,GAAG,CAACK,MAArB,CAAZ,CAAb;AACD;AAtBH;;AAyBAnC,MAAAA,MAAM,CAAC,IAAI6B,KAAJ,2BAA6BR,QAA7B,OAAD,CAAN;AACD,KA3BD;;AA6BAS,IAAAA,GAAG,CAACW,IAAJ,CAAS,IAAT;AACD,GApCM,CAAP;AAqCD","sourcesContent":["import prefetch from './utils/prefetch'\nimport { unslashEnd } from './utils/helpers'\nimport { NOT_FOUND_PATH } from '~/.temp/constants'\n\nconst dataUrl = process.env.DATA_URL\nconst isPrefetched = {}\nconst isLoaded = {}\n\nexport default (route, options = {}) => {\n  const { shouldPrefetch = false, force = false } = options\n\n  if (!process.isStatic) {\n    const { dynamic = false } = route.meta\n    let path = dynamic ? route.matched[0].path : route.path\n\n    if (route.name === '*') {\n      path = NOT_FOUND_PATH\n    }\n\n    return new Promise((resolve, reject) => {\n      if (force || !isLoaded[route.path]) {\n        isLoaded[route.path] = fetch(process.env.GRAPHQL_ENDPOINT, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ path, dynamic })\n        })\n          .then(res => res.json())\n          .catch(reject)\n      }\n\n      isLoaded[route.path]\n        .then(res => {\n          if (res.errors) reject(res.errors[0])\n          else if (res.code) resolve({ code: res.code })\n          else resolve({\n            data: res.data,\n            context: res.extensions\n              ? res.extensions.context\n              : {}\n          })\n\n          isLoaded[route.path] = null\n        })\n    })\n  }\n\n  const hashMeta = document\n    .querySelector('meta[name=\"gridsome:hash\"]')\n    .getAttribute('content')\n\n  return new Promise((resolve, reject) => {\n    const usePath = route.name === '*' ? NOT_FOUND_PATH : route.path\n    const jsonPath = route.meta.dataPath || unslashEnd(usePath) + '/index.json'\n    const absPath = unslashEnd(dataUrl) + jsonPath\n\n    if (shouldPrefetch && !isLoaded[jsonPath]) {\n      if (!isPrefetched[jsonPath]) {\n        isPrefetched[jsonPath] = prefetch(absPath)\n      }\n\n      return isPrefetched[jsonPath]\n        .then(() => resolve())\n        .catch(() => resolve())\n    }\n\n    if (!isLoaded[jsonPath]) {\n      isLoaded[jsonPath] = fetchJSON(absPath)\n    }\n\n    return isLoaded[jsonPath]\n      .then(res => {\n        if (res.hash !== hashMeta) reject(createError('Hash did not match.', 'INVALID_HASH'))\n        else resolve(res)\n      })\n      .catch(reject)\n  })\n}\n\nfunction createError (message, code) {\n  const error = new Error(message)\n  error.code = code\n  return error\n}\n\nfunction fetchJSON (jsonPath) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n\n    req.open('GET', jsonPath, true)\n    req.withCredentials = true\n\n    req.onload = () => {\n      switch (req.status) {\n        case 200: {\n          let results\n\n          try {\n            results = JSON.parse(req.responseText)\n          } catch (err) {\n            return reject(\n              new Error(`Failed to parse JSON from ${jsonPath}. ${err.message}.`)\n            )\n          }\n\n          if (!results.hash) {\n            return reject(\n              new Error(`JSON data in ${jsonPath} is missing a hash.`)\n            )\n          }\n\n          return resolve(results)\n        }\n        case 404: {\n          return reject(createError(req.statusText, req.status))\n        }\n      }\n\n      reject(new Error(`Failed to fetch ${jsonPath}.`))\n    }\n\n    req.send(null)\n  })\n}\n"]}]}