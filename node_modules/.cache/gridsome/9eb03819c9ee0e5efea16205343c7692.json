{"remainingRequest":"/Users/adewaleabati/Documents/code/acekyd/node_modules/babel-loader/lib/index.js??ref--1-1!/Users/adewaleabati/Documents/code/acekyd/node_modules/gridsome/app/fetchPath.js","dependencies":[{"path":"/Users/adewaleabati/Documents/code/acekyd/node_modules/gridsome/app/fetchPath.js","mtime":499162500000},{"path":"/Users/adewaleabati/Documents/code/acekyd/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/adewaleabati/Documents/code/acekyd/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es.function.name\";\nimport \"core-js/modules/es.object.to-string\";\nimport fetch from './fetch';\nimport router from './router';\nimport { getResults, setResults, formatError } from './graphql/shared';\nexport default function fetchPath(path) {\n  if (process.isServer) {\n    throw new Error(\"Cannot fetch \".concat(path, \" while rendering HTML. \") + \"This method should ony be used in the mounted hook.\");\n  }\n\n  var _router$resolve = router.resolve({\n    path: path\n  }),\n      route = _router$resolve.route;\n\n  var cached = getResults(route.path);\n  var notFoundErr = new Error(\"Could not find \".concat(path));\n  return new Promise(function (resolve, reject) {\n    if (route.fullPath !== path) return reject(notFoundErr);\n    if (route.name === '*') return reject(notFoundErr);\n    if (cached) return resolve(cached);\n    fetch(route).then(function (res) {\n      if (res.code === 404) reject(notFoundErr);else resolve(setResults(route.path, res));\n    })[\"catch\"](function (err) {\n      if (err.code === 'MODULE_NOT_FOUND' || err.code === 404) {\n        reject(notFoundErr);\n      } else {\n        formatError(err, route);\n        reject(err);\n      }\n    });\n  });\n}",{"version":3,"sources":["/Users/adewaleabati/Documents/code/acekyd/node_modules/gridsome/app/fetchPath.js"],"names":["fetch","router","getResults","setResults","formatError","fetchPath","path","process","isServer","Error","resolve","route","cached","notFoundErr","Promise","reject","fullPath","name","then","res","code","err"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEA,SACEC,UADF,EAEEC,UAFF,EAGEC,WAHF,QAIO,kBAJP;AAMA,eAAe,SAASC,SAAT,CAAoBC,IAApB,EAA0B;AACvC,MAAIC,OAAO,CAACC,QAAZ,EAAsB;AACpB,UAAM,IAAIC,KAAJ,CACJ,uBAAgBH,IAAhB,oFADI,CAAN;AAID;;AANsC,wBAQrBL,MAAM,CAACS,OAAP,CAAe;AAAEJ,IAAAA,IAAI,EAAJA;AAAF,GAAf,CARqB;AAAA,MAQ/BK,KAR+B,mBAQ/BA,KAR+B;;AASvC,MAAMC,MAAM,GAAGV,UAAU,CAACS,KAAK,CAACL,IAAP,CAAzB;AACA,MAAMO,WAAW,GAAG,IAAIJ,KAAJ,0BAA4BH,IAA5B,EAApB;AAEA,SAAO,IAAIQ,OAAJ,CAAY,UAACJ,OAAD,EAAUK,MAAV,EAAqB;AACtC,QAAIJ,KAAK,CAACK,QAAN,KAAmBV,IAAvB,EAA6B,OAAOS,MAAM,CAACF,WAAD,CAAb;AAC7B,QAAIF,KAAK,CAACM,IAAN,KAAe,GAAnB,EAAwB,OAAOF,MAAM,CAACF,WAAD,CAAb;AACxB,QAAID,MAAJ,EAAY,OAAOF,OAAO,CAACE,MAAD,CAAd;AAEZZ,IAAAA,KAAK,CAACW,KAAD,CAAL,CACGO,IADH,CACQ,UAAAC,GAAG,EAAI;AACX,UAAIA,GAAG,CAACC,IAAJ,KAAa,GAAjB,EAAsBL,MAAM,CAACF,WAAD,CAAN,CAAtB,KACKH,OAAO,CAACP,UAAU,CAACQ,KAAK,CAACL,IAAP,EAAaa,GAAb,CAAX,CAAP;AACN,KAJH,WAKS,UAAAE,GAAG,EAAI;AACZ,UAAIA,GAAG,CAACD,IAAJ,KAAa,kBAAb,IAAmCC,GAAG,CAACD,IAAJ,KAAa,GAApD,EAAyD;AACvDL,QAAAA,MAAM,CAACF,WAAD,CAAN;AACD,OAFD,MAEO;AACLT,QAAAA,WAAW,CAACiB,GAAD,EAAMV,KAAN,CAAX;AACAI,QAAAA,MAAM,CAACM,GAAD,CAAN;AACD;AACF,KAZH;AAaD,GAlBM,CAAP;AAmBD","sourcesContent":["import fetch from './fetch'\nimport router from './router'\n\nimport {\n  getResults,\n  setResults,\n  formatError\n} from './graphql/shared'\n\nexport default function fetchPath (path) {\n  if (process.isServer) {\n    throw new Error(\n      `Cannot fetch ${path} while rendering HTML. ` +\n      `This method should ony be used in the mounted hook.`\n    )\n  }\n\n  const { route } = router.resolve({ path })\n  const cached = getResults(route.path)\n  const notFoundErr = new Error(`Could not find ${path}`)\n\n  return new Promise((resolve, reject) => {\n    if (route.fullPath !== path) return reject(notFoundErr)\n    if (route.name === '*') return reject(notFoundErr)\n    if (cached) return resolve(cached)\n\n    fetch(route)\n      .then(res => {\n        if (res.code === 404) reject(notFoundErr)\n        else resolve(setResults(route.path, res))\n      })\n      .catch(err => {\n        if (err.code === 'MODULE_NOT_FOUND' || err.code === 404) {\n          reject(notFoundErr)\n        } else {\n          formatError(err, route)\n          reject(err)\n        }\n      })\n  })\n}\n"]}]}